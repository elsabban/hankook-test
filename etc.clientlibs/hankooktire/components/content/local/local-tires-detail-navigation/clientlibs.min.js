/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other entry modules.
(() => {

;// CONCATENATED MODULE: external "gsap"
const external_gsap_namespaceObject = gsap;
var external_gsap_default = /*#__PURE__*/__webpack_require__.n(external_gsap_namespaceObject);
;// CONCATENATED MODULE: external "window"
const external_window_namespaceObject = window;
;// CONCATENATED MODULE: external "Swiper"
const external_Swiper_namespaceObject = Swiper;
var external_Swiper_default = /*#__PURE__*/__webpack_require__.n(external_Swiper_namespaceObject);
;// CONCATENATED MODULE: ./src/components/local/local-tires-detail-navigation/clientlibs/js/set-swiper-b-type.js


/* harmony default export */ const set_swiper_b_type = (function () {
  external_Swiper_default().use([external_Swiper_namespaceObject.Navigation, external_Swiper_namespaceObject.Pagination, external_Swiper_namespaceObject.Scrollbar])

  const breakpoint = window.matchMedia('(min-width: 1025px)');
 
  let swiperList = [];
  
  const breakpointChecker = function() {
    console.log(swiperList.length)
    if(breakpoint.matches === true) {
      if(swiperList.length !== 0){
        swiperList.forEach((el) =>{
          console.log(el)
          el.destroy(true,true)
        })
      }
      return;
    } else if(breakpoint.matches === false) {
      return setSwiper();
    }
  }

  function setSwiper() {
    // Content A
    const $swiperContainersA = document.querySelectorAll('.ltdca .swiper');
    console.log($swiperContainersA)
    $swiperContainersA.forEach((el,index)=> {
       const swiper = new (external_Swiper_default())(el, {
       slidesPerView: 'auto',
       scrollbar: {
         el: '.ltdca .swiper-scrollbar',     
       },
       spaceBetween : 24,
       draggable : true,
       centerInsufficientSlides : true,
       
     });
     swiperList.push(swiper)
     console.log(swiperList)
    })

    // Content B
    const $swiperContainersB = document.querySelectorAll('.ltdcb .swiper');
    console.log($swiperContainersB)
    $swiperContainersB.forEach((el,index)=> {
       const swiper = new (external_Swiper_default())(el, {
       slidesPerView: 'auto',
       scrollbar: {
         el: '.ltdcb .swiper-scrollbar',     
       },
       spaceBetween : 24,
       draggable : true,
       centerInsufficientSlides : true,
       
     });
     swiperList.push(swiper)
     console.log(swiperList)
   })

    // Content C
    const $swiperContainersC = document.querySelectorAll('.ltdcc .swiper');
    console.log($swiperContainersC)
    $swiperContainersC.forEach((el,index)=> {
      const swiper = new (external_Swiper_default())(el, {
      slidesPerView: 'auto',
      scrollbar: {
        el: '.ltdcc .swiper-scrollbar',     
      },
      spaceBetween : 24,
      draggable : true,
      centerInsufficientSlides : true,
        
      });
      swiperList.push(swiper)
      console.log(swiperList)
    })

  }

  // Content E
  function setSwiperE() {
    const $swiperContainers = document.querySelectorAll('.ltdce .swiper');
    console.log($swiperContainers)
    $swiperContainers.forEach((el,index)=> {
        const swiper = new (external_Swiper_default())(el, {
        slidesPerView: 'auto',
        scrollbar: {
          el: '.ltdce .swiper-scrollbar',     
        },
        centerInsufficientSlides : true,
        spaceBetween : 14,
        draggable : true,
        freeMode : true,
        breakpoints : {
            1023: {
                slidesPerView : 3,
                spaceBetween : 30,
            }
        }
        
      });
    //  swiperList.push(swiper)
    //  console.log(swiperList)
    })
  }

  breakpoint.onchange = (e) => {
    breakpointChecker()
  }
  breakpointChecker();
  setSwiperE();
});
;// CONCATENATED MODULE: ./node_modules/gsap/ScrollToPlugin.js
/*!
 * ScrollToPlugin 3.9.1
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */
var ScrollToPlugin_gsap,
    _coreInitted,
    _window,
    _docEl,
    _body,
    _toArray,
    _config,
    _windowExists = function _windowExists() {
  return typeof window !== "undefined";
},
    _getGSAP = function _getGSAP() {
  return ScrollToPlugin_gsap || _windowExists() && (ScrollToPlugin_gsap = window.gsap) && ScrollToPlugin_gsap.registerPlugin && ScrollToPlugin_gsap;
},
    _isString = function _isString(value) {
  return typeof value === "string";
},
    _isFunction = function _isFunction(value) {
  return typeof value === "function";
},
    _max = function _max(element, axis) {
  var dim = axis === "x" ? "Width" : "Height",
      scroll = "scroll" + dim,
      client = "client" + dim;
  return element === _window || element === _docEl || element === _body ? Math.max(_docEl[scroll], _body[scroll]) - (_window["inner" + dim] || _docEl[client] || _body[client]) : element[scroll] - element["offset" + dim];
},
    _buildGetter = function _buildGetter(e, axis) {
  //pass in an element and an axis ("x" or "y") and it'll return a getter function for the scroll position of that element (like scrollTop or scrollLeft, although if the element is the window, it'll use the pageXOffset/pageYOffset or the documentElement's scrollTop/scrollLeft or document.body's. Basically this streamlines things and makes a very fast getter across browsers.
  var p = "scroll" + (axis === "x" ? "Left" : "Top");

  if (e === _window) {
    if (e.pageXOffset != null) {
      p = "page" + axis.toUpperCase() + "Offset";
    } else {
      e = _docEl[p] != null ? _docEl : _body;
    }
  }

  return function () {
    return e[p];
  };
},
    _clean = function _clean(value, index, target, targets) {
  _isFunction(value) && (value = value(index, target, targets));

  if (typeof value !== "object") {
    return _isString(value) && value !== "max" && value.charAt(1) !== "=" ? {
      x: value,
      y: value
    } : {
      y: value
    }; //if we don't receive an object as the parameter, assume the user intends "y".
  } else if (value.nodeType) {
    return {
      y: value,
      x: value
    };
  } else {
    var result = {},
        p;

    for (p in value) {
      result[p] = p !== "onAutoKill" && _isFunction(value[p]) ? value[p](index, target, targets) : value[p];
    }

    return result;
  }
},
    _getOffset = function _getOffset(element, container) {
  element = _toArray(element)[0];

  if (!element || !element.getBoundingClientRect) {
    return console.warn("scrollTo target doesn't exist. Using 0") || {
      x: 0,
      y: 0
    };
  }

  var rect = element.getBoundingClientRect(),
      isRoot = !container || container === _window || container === _body,
      cRect = isRoot ? {
    top: _docEl.clientTop - (_window.pageYOffset || _docEl.scrollTop || _body.scrollTop || 0),
    left: _docEl.clientLeft - (_window.pageXOffset || _docEl.scrollLeft || _body.scrollLeft || 0)
  } : container.getBoundingClientRect(),
      offsets = {
    x: rect.left - cRect.left,
    y: rect.top - cRect.top
  };

  if (!isRoot && container) {
    //only add the current scroll position if it's not the window/body.
    offsets.x += _buildGetter(container, "x")();
    offsets.y += _buildGetter(container, "y")();
  }

  return offsets;
},
    _parseVal = function _parseVal(value, target, axis, currentVal, offset) {
  return !isNaN(value) && typeof value !== "object" ? parseFloat(value) - offset : _isString(value) && value.charAt(1) === "=" ? parseFloat(value.substr(2)) * (value.charAt(0) === "-" ? -1 : 1) + currentVal - offset : value === "max" ? _max(target, axis) - offset : Math.min(_max(target, axis), _getOffset(value, target)[axis] - offset);
},
    _initCore = function _initCore() {
  ScrollToPlugin_gsap = _getGSAP();

  if (_windowExists() && ScrollToPlugin_gsap && document.body) {
    _window = window;
    _body = document.body;
    _docEl = document.documentElement;
    _toArray = ScrollToPlugin_gsap.utils.toArray;
    ScrollToPlugin_gsap.config({
      autoKillThreshold: 7
    });
    _config = ScrollToPlugin_gsap.config();
    _coreInitted = 1;
  }
};
var ScrollToPlugin = {
  version: "3.9.1",
  name: "scrollTo",
  rawVars: 1,
  register: function register(core) {
    ScrollToPlugin_gsap = core;

    _initCore();
  },
  init: function init(target, value, tween, index, targets) {
    _coreInitted || _initCore();
    var data = this,
        snapType = ScrollToPlugin_gsap.getProperty(target, "scrollSnapType");
    data.isWin = target === _window;
    data.target = target;
    data.tween = tween;
    value = _clean(value, index, target, targets);
    data.vars = value;
    data.autoKill = !!value.autoKill;
    data.getX = _buildGetter(target, "x");
    data.getY = _buildGetter(target, "y");
    data.x = data.xPrev = data.getX();
    data.y = data.yPrev = data.getY();

    if (snapType && snapType !== "none") {
      // disable scroll snapping to avoid strange behavior
      data.snap = 1;
      data.snapInline = target.style.scrollSnapType;
      target.style.scrollSnapType = "none";
    }

    if (value.x != null) {
      data.add(data, "x", data.x, _parseVal(value.x, target, "x", data.x, value.offsetX || 0), index, targets);

      data._props.push("scrollTo_x");
    } else {
      data.skipX = 1;
    }

    if (value.y != null) {
      data.add(data, "y", data.y, _parseVal(value.y, target, "y", data.y, value.offsetY || 0), index, targets);

      data._props.push("scrollTo_y");
    } else {
      data.skipY = 1;
    }
  },
  render: function render(ratio, data) {
    var pt = data._pt,
        target = data.target,
        tween = data.tween,
        autoKill = data.autoKill,
        xPrev = data.xPrev,
        yPrev = data.yPrev,
        isWin = data.isWin,
        snap = data.snap,
        snapInline = data.snapInline,
        x,
        y,
        yDif,
        xDif,
        threshold;

    while (pt) {
      pt.r(ratio, pt.d);
      pt = pt._next;
    }

    x = isWin || !data.skipX ? data.getX() : xPrev;
    y = isWin || !data.skipY ? data.getY() : yPrev;
    yDif = y - yPrev;
    xDif = x - xPrev;
    threshold = _config.autoKillThreshold;

    if (data.x < 0) {
      //can't scroll to a position less than 0! Might happen if someone uses a Back.easeOut or Elastic.easeOut when scrolling back to the top of the page (for example)
      data.x = 0;
    }

    if (data.y < 0) {
      data.y = 0;
    }

    if (autoKill) {
      //note: iOS has a bug that throws off the scroll by several pixels, so we need to check if it's within 7 pixels of the previous one that we set instead of just looking for an exact match.
      if (!data.skipX && (xDif > threshold || xDif < -threshold) && x < _max(target, "x")) {
        data.skipX = 1; //if the user scrolls separately, we should stop tweening!
      }

      if (!data.skipY && (yDif > threshold || yDif < -threshold) && y < _max(target, "y")) {
        data.skipY = 1; //if the user scrolls separately, we should stop tweening!
      }

      if (data.skipX && data.skipY) {
        tween.kill();
        data.vars.onAutoKill && data.vars.onAutoKill.apply(tween, data.vars.onAutoKillParams || []);
      }
    }

    if (isWin) {
      _window.scrollTo(!data.skipX ? data.x : x, !data.skipY ? data.y : y);
    } else {
      data.skipY || (target.scrollTop = data.y);
      data.skipX || (target.scrollLeft = data.x);
    }

    if (snap && (ratio === 1 || ratio === 0)) {
      y = target.scrollTop;
      x = target.scrollLeft;
      snapInline ? target.style.scrollSnapType = snapInline : target.style.removeProperty("scroll-snap-type");
      target.scrollTop = y + 1; // bug in Safari causes the element to totally reset its scroll position when scroll-snap-type changes, so we need to set it to a slightly different value and then back again to work around this bug.

      target.scrollLeft = x + 1;
      target.scrollTop = y;
      target.scrollLeft = x;
    }

    data.xPrev = data.x;
    data.yPrev = data.y;
  },
  kill: function kill(property) {
    var both = property === "scrollTo";

    if (both || property === "scrollTo_x") {
      this.skipX = 1;
    }

    if (both || property === "scrollTo_y") {
      this.skipY = 1;
    }
  }
};
ScrollToPlugin.max = _max;
ScrollToPlugin.getOffset = _getOffset;
ScrollToPlugin.buildGetter = _buildGetter;
_getGSAP() && ScrollToPlugin_gsap.registerPlugin(ScrollToPlugin);

;// CONCATENATED MODULE: ./src/components/local/local-tires-detail-navigation/clientlibs/js/main.js
function main() {
    let $lnbGlobalContainer;
    let $lnbWrapper;
    let navInfo = {};
    let scrollTop = 0;
    let scrollDirection = 'down';
    let initTop = 0;
    let isM = false;
    let windowWidth = window.innerWidth;
    const $locomotive = window.locomotive;
    const BREAK_POINT_TABLET = 1025;
    const $typeB = document.querySelector('.ltdn.type-b');
    const $nav = document.querySelector('.ltdn');
    const $header = document.querySelector('#header');
    const $navPoint = document.getElementById('nav-point');

    external_gsap_default().registerPlugin(external_window_namespaceObject.ScrollTrigger);
    external_gsap_default().registerPlugin(ScrollToPlugin);

    /*scrolltrigger X locomotive */
    external_window_namespaceObject.ScrollTrigger.scrollerProxy("[data-scroll-container]", {
        scrollTop(value) {
            return arguments.length ? window.locomotive.scrollTo(value, 0, 0) : window.locomotive.scroll.instance.scroll.y;
        },
        getBoundingClientRect() {
            return { top: 0, left: 0, width: window.innerWidth, height: window.innerHeight };
        },
        pinType: document.querySelector("[data-scroll-container]").style.transform ? "transform" : "fixed"
    });

    external_window_namespaceObject.ScrollTrigger.addEventListener("refresh", () => window.locomotive.update());
    external_window_namespaceObject.ScrollTrigger.refresh();

    $locomotive.on('scroll', scrollHandler);

    // [NOTE] A/B 타입 분기
    if($typeB) {
        initTypeB();
        set_swiper_b_type();
    } else {
        initStatus();
    }

    window.addEventListener('resize', () => {
        
        if(document.querySelector('[data-author]')) {
            const authorFlag = parseInt(document.querySelector('[data-author]').getAttribute('data-author'));
            // [NOTE] AEM 어써링 시 리사이즈 버그가 있어 html 속성 author를 이용한 예외처리 코드
            if(!authorFlag) {
                requestAnimationFrame(resizeHandler);
            }
        } else {
            requestAnimationFrame(resizeHandler);
        }
    }, false);

    window.addEventListener('keydown',(e)=>{
        if(e.key === '1'){
            requestAnimationFrame(resizeHandler)
            initNavStatus();
            navStatus();
        }
    })

    initNavStatus();
    resizeHandler();
    eventHandler();
    initRecentProducts();

    function resizeHandler(){
        windowWidth = window.innerWidth;
        isM = windowWidth < BREAK_POINT_TABLET;
    }

    function scrollHandler(){
        external_window_namespaceObject.ScrollTrigger.update();
        scrollTop = $locomotive.scroll.instance.scroll.y;
        scrollDirection = $locomotive.scroll.instance.direction;

        // [NOTE] type-b 일 때 스크롤에 따른 lnb 이동
        if($typeB) {
            // const lnbHeight = isM ? 64 : 68;
            const $lnb = document.querySelector('.ltdn.type-b');
            const lnbHeight = $lnb.clientHeight;
            const kvH = document.querySelector('.ltdk').offsetHeight + lnbHeight;

            if(scrollTop > kvH) {
                $lnbGlobalContainer.appendChild($nav);
                const hideTop = $header.offsetHeight;
                $header.style.top = -hideTop + 'px';
                $nav.style.position = 'fixed';
                $nav.style.width = '100%';
                $typeB.classList.add('fixed')
            } else {
                const $main = document.getElementById('main');
                $lnbWrapper.appendChild($nav);
                $header.style.top = '';
                $nav.style = 'none';
                $typeB.classList.remove('fixed')
            }
        }

        const visibleTiming = $typeB ? document.querySelector('.ltdk').offsetHeight + 86 : 100;
        if(isM) headerVisible(visibleTiming);
        controlNav();
        navStatus();
        initNavStatus();
    }

    function headerVisible(timing){
        if(scrollTop > timing){
            if(scrollDirection !== 'down') return;
            if(!$header.classList.contains('hide')) $header.classList.add('hide');
        }else{
            if(scrollDirection === 'down') return;
            if($header.classList.contains('hide')) $header.classList.remove('hide');
        }
    }

    function initNavStatus(){

        document.querySelectorAll('.menu-list button').forEach( btn => {
            const name = btn.dataset.target.replace('#',"");
            const el = document.getElementById(name);

            if(!el) return;

            let offset = 0;
            if($typeB) offset = $typeB.offsetHeight + 1;
            navInfo[name] = el.getBoundingClientRect().top - offset;
        })
    }

    function navStatus(){
        let current = '';
        const targetPos = Math.max(... Object.values(navInfo).filter(el => el <= 0))
        // console.log(targetPos)
        current = Object.keys(navInfo).find( key => navInfo[key] === targetPos);
        const activeBtn = document.querySelectorAll('.menu-box button[data-target="#'+current+'"]');
        // console.log(activeBtn.length)

        if(activeBtn.length > 0){
            if(activeBtn[0].classList.contains('active')) return;

            document.querySelectorAll('.menu-box button').forEach( btn => {
                btn.classList.remove('active');
            })

            activeBtn[0].classList.add('active');
            document.querySelector('.menu-box .select-box .btn').innerHTML = activeBtn[1].innerHTML;

        }

        // console.log(activeBtn)
    }

    window.addEventListener('keydown',(e)=>{
        if(e.key === 'c'){
            initNavStatus();
            navStatus();
            console.log(navInfo)
        }
    })

    function controlNav(){
        const $navEl = document.querySelector('.ltdn');

        if(!$navEl || !$navPoint) return;

        const pointRectInfo = $navPoint.getBoundingClientRect();
        if(initTop === 0) initTop = pointRectInfo.top + pointRectInfo.height / 2;

        const isDown = scrollDirection === 'down';
        let status = '';

        if(isDown && !$navEl.classList.contains('show') && initTop < scrollTop){
            status = 'add';
        } else if(!isDown && $navEl.classList.contains('show')){
            status = 'remove';
        }

        if(isM){
            if(initTop < scrollTop) status = 'add';
            else status = 'remove';
        }

        status && $navEl.classList[status]('show');
    }

    function initTypeB() {
        !$nav.classList.contains('show') && $nav.classList.add('show')
        // [NOTE] lnb 잘라붙일 컨테이너
        $lnbGlobalContainer = document.createElement('div');
        document.querySelector('body').append($lnbGlobalContainer);

        // [NOTE] lnb wrapper
        $lnbWrapper = document.createElement('div');
        $lnbWrapper.id = 'lnb-wrapper';
        $nav.parentNode.insertBefore($lnbWrapper, $nav.parentNode.children[1]);
        $lnbWrapper.appendChild($nav);
    }

    function initStatus() {
        if(!$nav) return;

        let navClon = document.createElement('div');
        navClon.className = 'ltdn';
        navClon.innerHTML = $nav.innerHTML;
        $nav.remove();

        document.querySelector('body').append(navClon);

        window.setSelectBox();

        document.querySelector('.ltdn .btn--arrow').addEventListener('click', function(){
            window.openPop('allow_pop2')
        })

        document.getElementById('util-find-tire').classList.add('hide')
    }
 
    function index(el) {
        if(!el) return;

        var i = 0;
        while (el = el.previousElementSibling) i++;

        return i;
    }

    /*
    메뉴 버튼 data-target 에 지정된 셀렉터로 이동
    */


    function onCompleteScroll(){
            navStatus()
        // console.log('complete')
    }
    function eventHandler(){
        document.querySelectorAll('.menu-box button').forEach( btn => {
            btn.addEventListener('click', function(){
                console.log('클릭!')
                const target = btn.dataset.target;
                const targetT = target ? target.replace("#","") : null;

                
                const $recentProduct = document.querySelector('#recent-product');
                $recentProduct.classList.add('hide');
                const visibility = Number(!$recentProduct.classList.contains('hide'));
                external_gsap_default().to($recentProduct, { autoAlpha: visibility })
                external_gsap_default().to('.ltdn .dimmed', { autoAlpha: visibility })
                
                
                if(targetT && document.getElementById(targetT)){
                    const scrollStatus = !!document.querySelector('.has-scroll-smooth');
                    if(scrollStatus){
                        $locomotive.scrollTo(document.getElementById(targetT), { offset: $typeB ? -$typeB.offsetHeight : 1, callback : onCompleteScroll})
                    } else{
                        const scrollY = window.locomotive && window.locomotive.scroll.instance.scroll.y;
                        const targetY = document.getElementById(targetT).getBoundingClientRect().top
                        const targetPos = scrollY + targetY
                        external_gsap_default().to(window, {duration: 1.25, ease:Quart.easeInOut, scrollTo: targetPos + ( $typeB ? (-$typeB.offsetHeight) : 1), onComplete : onCompleteScroll});
                    }
                };

                btnStyle(btn);

                if (window.CustomEvent && typeof window.CustomEvent === 'function') {
                    var event = new CustomEvent('animatingScroll', {detail: {duration: 500}});
                } else {
                    var event = document.createEvent('CustomEvent');
                    event.initCustomEvent('animatingScroll', true, true, {duration: 500});
                }

                window.dispatchEvent(event);
            });
        });
    }

    function btnStyle(btn){
        document.querySelectorAll('.menu-list button').forEach( el => {
            if(el.classList.contains('active')) el.classList.remove('active');
        });
        const styleTarget = btn.querySelector('button') ? btn.querySelector('button') : btn;
        styleTarget.classList.add('active');
    }

    function initRecentProducts() {
        const $swiperContainer = document.querySelector('.recent-product__swiper');
        if($swiperContainer) {
          external_Swiper_default().use([external_Swiper_namespaceObject.Pagination]);
          const swiper = new (external_Swiper_default())($swiperContainer, {
            slidesPerView: 1.2,
            pagination: {
                el: '.swiper-pagination',
                clickable: true,
            },
            breakpoints: { 
                767: { 
                    slidesPerView: 2.2,
                },
                1023: { 
                    slidesPerView: 2.2,
                },
                1600: {
                    slidesPerView: 3,
                }
            }
          });

          const $btnRecent = document.getElementById('btn-recent-product');
          const $recentProduct = document.getElementById('btn-close-product');
          
          $btnRecent.addEventListener('click', function(e) {
            
            
            const activatedDropbox = $('.select-box .drop-box.active')

            if(activatedDropbox) {
                $(activatedDropbox).siblings().each((index, el) => {
                    if (el.matches('.btn.open')){
                        el.classList.remove('open')
                    }
                })
                $(activatedDropbox).css({height : '0px'});
                $(activatedDropbox).removeClass('active');
            }


              const target = this.getAttribute('href').replace('#', '');

              const $container = document.getElementById(target);

              $container.classList.toggle('hide');

              const visibility = Number(!$container.classList.contains('hide'));

              external_gsap_default().to($container, { autoAlpha: visibility })
              external_gsap_default().to('.ltdn .dimmed', { autoAlpha: visibility })

              e.preventDefault();
              e.stopPropagation();
          })

          $recentProduct.addEventListener('click', function() {
              const $container = document.getElementById('recent-product');
              $container.classList.add('hide');
              const visibility = Number(!$container.classList.contains('hide'));
              external_gsap_default().to($container, { autoAlpha: visibility })
              external_gsap_default().to('.ltdn .dimmed', { autoAlpha: visibility })
          })
          
        }
    }
}
window.addEventListener('compFuncRun', main);
})();

// This entry need to be wrapped in an IIFE because it need to be isolated against other entry modules.
(() => {
// extracted by mini-css-extract-plugin

})();

/******/ })()
;
/**
 * 
 */

$(document).ready(function(){
    //$.Session("recentList","[{\"type\":\"car\"}]")
    const name = "prd_" +$("#btn-recent-product").data("sitecd") + "_"+ 
        $("#btn-recent-product").data("vehicletype") + "_" + $("#btn-recent-product").data("seq");
    const value = {
        type : $("#btn-recent-product").data("vehicletype"),
        seq : $("#btn-recent-product").data("seq")
    };
    //setSession(name,JSON.stringify(value),10);
    //setSession("prd_car_18237",JSON.stringify({type : "car", seq : 18237}),10);
    
    setPrdSession(name,JSON.stringify(value));
    const arr = getPrdSession();
    
    $("#btn-recent-product > span.num").text(arr.length);
    $("#recent-product span.num").text(arr.length);
    const products = getRecentlyProducts(arr);
    populateRecentryProducts(products);
});
function getSessionStorage(key){
     return JSON.parse(sessionStorage.getItem(key)); 
}
function setSessionStorage(key, value){
    sessionStorage.setItem(key,value);
}
function removeSessionStorage(key){
    sessionStorage.removeItem(key);
} 
function setPrdSession(name, value) {
    if(getSessionStorage(name) != null) {
        removeSessionStorage(name);
        setSessionStorage(name,value);
        return;
    }
    
    const arr = getPrdSessionNm();
    if (arr.length > 4) {
        for(let i = 0; i <(arr.length - 4); i++) {
            removeSessionStorage(arr[i]);
        }
    }
    setSessionStorage(name,value);
    return;
}
function getPrdSessionNm() {
    const ca = Object.keys(sessionStorage);
    let arr = new Array();
    $.each(ca, function(i, data){
        data = data.trim();
        if(data.startsWith("prd_"+$("#btn-recent-product").data("sitecd") + "_")){
             arr.push(data);
        }
    })
    return arr;

}
function getPrdSession() {
    const ca = Object.keys(sessionStorage);
    let arr = new Array();
    $.each(ca, function(i, data){
        data = data.trim();
        if(data.startsWith("prd_"+$("#btn-recent-product").data("sitecd") + "_")){
             arr.push(getSessionStorage(data));
        }
    })
    return arr;

}
function getRecentlyProducts(param) {
    let result;
    // $.ajax({
    //         type: "POST",
    //         url: "/wsvc/api/localTiresDtlNavi.do",
    //         data : { 
    //             "data" : JSON.stringify(param) ,
    //             "siteCd" : $("#btn-recent-product").data("sitecd") 
    //         },
    //         dataType : "json",
    //         //contentType : "application/json; charset=UTF-8",
    //         async: false,
    //         success: function(data) {
    //             if ("0000" == data.resultCode) {
    //                 result =  data.data;
    //             }
    //             else {
    //                 alert(data.message);
    //             }
    //         },
    //         error : function(){
    //             alert('ajax Error');
    //         }
    // });
    
    return result;
    
}
function populateRecentryProducts(list) {
    const target = $(".ltdn .recent-product__swiper > .swiper-wrapper");
    let html = ""
    target.html(html);
    $.each(list, function(idx, data) {
        html += "<li class='tire-item swiper-slide'><div class='in-nav'>";
        html += populateProduct(data, data.TYPE, false);
        html += "</div></li>";
        
  });
    
    target.append(html);
    
}
